---
layout: post
title: C语言MakeFile的编写与使用、管道原理及应用、指针与内存
date: 2019-11-16
tags: C语言
---

# C语言

## 简介

C 语言是一种通用的、面向过程式的计算机程序设计语言。

C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。

在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&R 标准。

UNIX 操作系统，C编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。

- 易于学习。
- 结构化语言。
- 它产生高效率的程序。
- 它可以处理底层的活动。
- 它可以在多种计算机平台上编译。

## 关于 C

- C 语言是为了编写 UNIX 操作系统而被发明的。
- C 语言是以 B 语言为基础的，B 语言大概是在 1970 年被引进的。
- C 语言标准是于 1988 年由美国国家标准协会（ANSI，全称 American National Standard Institute）制定的。
- 截至 1973 年，UNIX 操作系统完全使用 C 语言编写。
- 目前，C 语言是最广泛使用的系统程序设计语言。
- 大多数先进的软件都是使用 C 语言实现的。
- 当今最流行的 Linux 操作系统和 RDBMS（Relational Database Management System：关系数据库管理系统） MySQL 都是使用 C 语言编写的。

## 为什么要使用 C？

C 语言最初是用于系统开发工作，特别是组成操作系统的程序。由于 C 语言所产生的代码运行速度与汇编语言编写的代码运行速度几乎一样，所以采用 C 语言作为系统开发语言。下面列举几个使用 C 的实例：

- 操作系统
- 语言编译器
- 汇编器
- 文本编辑器
- 打印机
- 网络驱动器
- 现代程序
- 数据库
- 语言解释器
- 实体工具

## C程序结构

C 程序主要包括以下部分：

- 预处理器指令
- 函数
- 变量
- 语句 & 表达式
- 注释

-------------------------------

- 所有的 C 语言程序都需要包含 **main()** 函数。 代码从 **main()** 函数开始执行。
- **/\* ... \*/** 用于注释说明。
- **printf()** 用于格式化输出到屏幕。**printf()** 函数在 **"stdio.h"** 头文件中声明。
- **stdio.h** 是一个头文件 (标准输入输出头文件) , **#include** 是一个预处理命令，用来引入头文件。 当编译器遇到 **printf()** 函数时，如果没有找到 **stdio.h** 头文件，会发生编译错误。
- **return 0;** 语句用于表示退出程序。

---------------------------------

## 多文件操作

`vim main.c`编写一个源码文件main.c

```c
#include <stdio.h>
int main()
{
    int a1 = 33;
    int a2 = 21;
    int maxNum = max(a1, a2);
    printf("the max value is %d", maxNum);
    return 0;
}
```

```c
int max (int a, int b)
{
    if(a > b)
    {
        return a;
    } else
    {
        return b;
    }
}
```



在vim命令模式中`:sp max.c`可以新建一个max.c文件(并同时打开)

<kbd>CTRL</kbd> + <kbd>W</kbd> + 上下方向键可以切换光标到需要编辑的文件中

`:qwa`表示保存退出(a代表all，也就是全部保存并退出)

`gcc -c max.c -o max.out`编译源文件max.c

然后再`gcc max.c main.c -o main.out`

这样编译的好处就是函数源文件不需要多次编译，节省时间，提高效率。哪个文件里用到这个函数就只需要把这个函数编译后的文件拿出来一同编译。这种做法就是把不需要再修改的函数全部编译过后放在一起生成一个静态库。

--------------



但是如果想使用其他人写的函数，但是不知道函数的参数规则，就可以写一个.h文件

`vim max.h`

```c
int max(int a, int b);
```

然后在main.c头部引入#include "max.h"



```c
#include <stdio.h>
#include "max.h"
int main()
{
    int a1 = 33;
    int a2 = 21;
    int maxNum = max(a1, a2);
    printf("the max value is %d", maxNum);
    return 0;
}
```

然后再重新编译`gcc max.c main.c -o main.out`

---------------------------------

## Makefile的编写

写Makefile文件可以高效率的编译大量的源文件，也避免了重复去编译同一个源文件

假如有一个main.c文件，里面调用了两个函数max和min，也就有了max.c和min.c

`vim Makefile`

```c
# this is make file
main.out:max.o min.o main.c
         gcc max.o min.o main.c //前面必须有8个空格也就是一个制表符Tab,下面每一个类似的都是如此
max.o:max.c
         gcc -c max.c
min.o:min.c
         gcc -c min.c
```

然后输入命令`make`就可以了

-----------------------------

linux里两个命令可以用&&连接起来

程序执行成功才return 0,输入命令echo$?可以查看上个命令执行返回的错误信息

## 标准输入流输出流以及错误流

stdin 标准输入流，标准的输入设备默认键盘

stdout 标准输出流，标准的输出设备默认屏幕

stderr 标准错误流，只有程序出错时才会执行的流程

printf(“abc”) 是对fprintf(stdout,”abc”)函数的封装.把“ ”内的内容写入到stdout文件里去，stdout其实就是默认显示器（屏幕）

scanf(“%d”,&a) 是对fscanf(stdin,”%d”,&a)函数的封装.用键盘往a变量中输入一个数据

```
#include <stdio.h>
int main()
{
    printf("hello world!\n");//调用了标准输出流的功能
    int a;
    scanf("%d", &a);//调用了标准输入流的功能
    printf("input value is :%d\n", a);
    return 0;
}123456789
```

实际上我们的操作系统，当我们执行程序的一瞬间，./a.out的一瞬间，它会

为我们应用程序启动一个东西叫进程，那么启动进程的同时，它会给我们提

供一系列的指针。

Linux把所有的东西都当作文件来处理，如果外接了个打印机，它把打印

机当作文件，外接了个U盘，它把U盘也当做文件。

它认为所有的外部设备和磁盘里保存的文件是一样的。 

它把所有的东西都当作文件来处理，那么当我们启动应用程序的时候，它也当我们这个应用程序要和文件交互，它会默认帮我们创建三个文件

```
/*
stdin
stdout
stderr

*/123456
```

如果要读取一个设备的信息，就是通过标准输入流stdin来读取的。

如果我让我的这个应用程序读取的数据来自于键盘，那么我们就是接收来自

键盘的输入，当然我认为它来自于光盘，那么它读的就是光盘里的输入的文件。

所以，stdin就负责往这个程序里输入数据。

标准错误流：

```
#include <stdio.h>
int main()
{
    printf("please input the value a :\n");//调用了标准输出流的功能
    //fprintf(stdout,"please input the value a :\n");
    int a;
    scanf("%d", &a);//调用了标准输入流的功能
    //fscanf(stdin,"%d",&a);
    //我们要求a>0
    if (a < 0)
    {   fprintf(stderr,"the value must > 0");
        return 1;//让电脑知道程序出错，main函数返回值不等于0
    }
    return 0;
}
```

---------------------

## 管道原理及应用

`ls /etc/ | grep 想查的文件名包含的字串`

ls /etc/是查看etc下所有目录和文件，利用管道把这条命令的输出流的内容当做下个命令输入流的内容

grep可以从文本文档里查询包含指定字符的行，也可以当成文本搜索命令

---------------

`ps -ef | grep ssh`查找所有进程里面包含ssh的进程

*ps* -*e*f表示查看全格式的全部进程。e、f代表不同的意思 e 显示所有进程(-*e* all processes ) f 全格式(-f full)

# C语言指针与内存

## 指针

每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。

## 什么是指针？

**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

```
type *var-name;
```

在这里，**type** 是指针的基类型，它必须是一个有效的 C 数据类型，**var-name** 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：

int    *ip;    /* 一个整型的指针 */ double *dp;    /* 一个 double 型的指针 */ float  *fp;    /* 一个浮点型的指针 */ char   *ch;     /* 一个字符型的指针 */

所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。

不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

-------------------------

## GDB调试

GDB是linux下的终端调试工具，它可以让我们通过调试查看内存的数据

想让可执行文件能够用GDB进行调试,用gcc编译的时候就要加上`-g`,例如：

`gcc -g main.c -o main.out`

用GDB调试可执行文件：

`gdb 文件名`

### gdb常用命令

回车键：重复上一命令

（gdb）help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h

（gdb）run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r

（gdb）start：单步执行，运行程序，停在第一执行语句

（gdb）list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l

（gdb）set：设置变量的值

（gdb）next：单步调试（逐过程，函数直接执行）,简写n

（gdb）step：单步调试（逐语句：跳入自定义函数内部执行）,简写s

（gdb）backtrace：查看函数的调用的栈帧和层级关系,简写bt

（gdb）frame：切换函数的栈帧,简写f

（gdb）info：查看函数内部局部变量的数值,简写i

（gdb）finish：结束当前函数，返回到函数调用点

（gdb）continue：继续运行,简写c

（gdb）print：打印值及地址,简写p

（gdb）quit：退出gdb,简写q

 

（gdb）break+num：在第num行设置断点,简写b

（gdb）info breakpoints：查看当前设置的所有断点

（gdb）delete breakpoints num：删除第num个断点,简写d

（gdb）display：追踪查看具体变量值

（gdb）undisplay：取消追踪观察变量

（gdb）watch：被设置观察点的变量发生修改时，打印显示

（gdb）i watch：显示观察点

（gdb）enable breakpoints：启用断点

（gdb）disable breakpoints：禁用断点

（gdb）x：查看内存x/20xw 显示20个单元，16进制，4字节每单元

（gdb）run argv[1] argv[2]：调试时命令行传参

（gdb）set follow-fork-mode child#Makefile项目管理：选择跟踪父子进程（fork()）

  core文件：先用$ ulimit -c 1024 开启core，当程序出错会自动生成core文件。调试时 gdb a.out core

 

ctrl+c：退出输入

-------------------------------------------------------

## C语言空间内存分布

**BSS段:**（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。

**数据段**：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。

**代码段:** 代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的代码属于只读。在代码段中，字符串常量也属于这部分。

 

**堆（heap）**：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。

**栈(stack)**：栈又称堆栈，存放程序的局部变量除此以外，在函数被调用时，栈用来传递参数和返回值等。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。

下面图来自UNIX环境高级编程书中：

![aaa](/images/posts/clang/25114105_Xc9r.jpg)

 


![img](/images/posts/clang/20160101140057681.png)

 

左边是UNIX/LINUX系统下可执行文件内部的组织结构，右边是可执行文件对应到进程逻辑地址空间（即内存）的划分情况。


首先是堆栈区(stack)，堆栈是由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。栈的申请是由系统自动分配，如在函数内部申请一个局部变量 int h，同时判别所申请空间是否小于栈的剩余空间，如若小于的话，在堆栈中为其开辟空间，为程序提供内存，否则将报异常提示栈溢出。  

其次是堆(heap)，堆一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。堆的申请是由程序员自己来操作的，在C中使用malloc函数，而C++中使用new运算符，但是堆的申请过程比较复杂：当系统收到程序的申请时，会遍历记录空闲内存地址的链表，以求寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，此处应该注意的是有些情况下，新申请的内存块的首地址记录本次分配的内存块大小，这样在delete尤其是 delete[]时就能正确的释放内存空间。

接着是全局数据区(静态区) (static)，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。另外文字常量区，常量字符串就是放在这里，程序结束后有系统释放。

最后是程序代码区，放着函数体的二进制代码。

举例说明一下:
int a = 0;          //全局初始化区
char *p1;         //全局未初始化区 


int main()
{
    int b;         // 栈
    char s[] = "abc";    //栈
    char *p2;       //栈
    char *p3 = "123456";  //123456\0在常量区，而p3在栈上

​    static int c =0；   //全局（静态）初始化区 

​    p1 = (char *)malloc(10);

​    p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区

​    strcpy(p1, "123456");   //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。

​    return 0;
}

 

1、进程地址空间

一个进程一旦建立，就会自认为占有4G内存（X86_32），这个内存被称作虚拟内存，也就是进程的地址空间。在Linux下，进程地址空间的布局大致如下图所示，其中的用户空间大致由这些部分组成：

1. 代码段
2. 初始化数据段
3. 未初始化数据段
4. 堆
5. 栈

![img](/images/posts/clang/292145580751946.png)

这些段，反映到ELF格式的目标文件（object file）中，就又可能由许多不同的节（section）组成。

-----------------------------------------------------------------

## 指向数组的指针

数组名是一个指向数组中第一个元素的常量指针。因此，在下面的声明中：

```
double balance[50];
```

**balance** 是一个指向 &balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 **p** 赋值为 **balance** 的第一个元素的地址：

```
double *p;
double balance[10];

p = balance;
```

使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。

-----------------------------------------------------

参考视频：

[Linux C语言编程基本原理与实践](https://www.imooc.com/learn/248)

[Linux C语言指针与内存](https://www.imooc.com/learn/394)